# Задачи курса "Объектно-ориентированное программирование на Java"

1. [Range](#range)
2. [Shapes](#shapes)
3. [Vector](#vector)
4. [Matrix](#matrix)
5. [List](#list)
6. [ArrayList](#array-list)
7. [ArrayListHome](#array-list-home)
8. [HashTable](#hash-table)
9. [BinarySearchTree](#binary-search-tree)
10. [Graph](#graph)
11. [Лямбда-функции](#lambda)
12. [Temperature](#temperature)
13. [Пул потоков](#thread-pool)
14. [Производитель - Потребитель](#producer-consumer)

### <span id="range">Задача [Range](Range):</span>

**Часть 1.** Создать класс Range (непрерывный вещественный числовой диапазон на прямой). 
В нём:
1.	Объявить два вещественных поля from, to
2.	Описать конструктор, при помощи которого заполняются поля
3.	Реализовать геттеры и сеттеры для полей
4.	Сделать метод для получения длины диапазона
5.	Сделать метод isInside, который принимает вещественное число и возвращает boolean – результат проверки, принадлежит ли число диапазону

После этого написать небольшую программу с использованием этого класса.

**Часть 2.** Доработать класс Range, реализовать методы:
1. Получение интервала-пересечения двух интервалов. Если пересечения нет, выдать null
2. Если есть, то выдать новый диапазон с соответствующими концами
3. Получение объединения двух интервалов. Может получиться 1 или 2 отдельных куска
4. Получение разности двух интервалов. Может получиться 0, 1 или 2 отдельных куска

* В операциях, где может получиться 2 куска, нужно выдавать массив объектов Range.
* Разность нужна несимметричная – из первого интервала вычитаем второй.
* Эти методы нужно сделать нестатическими.
* В пересечении и разности если диапазоны пересекаются только по 1 концу, считаем, что пересечения нет. В объединении что есть.

В main написать программу для проверки этих методов.


### <span id="shapes">Задача [Shapes](Shapes):</span>

**Часть 1.** Создать иерархию классов для геометрических фигур.

Реализовать методы:
- getWidth()
- getHeight()
- getArea()
- getPerimeter()

Все фигуры должны реализовывать этот интерфейс и правильным образом определять данные методы

1.	Square – квадрат. Должен иметь конструктор, принимающий длину стороны.

2.	Triangle – треугольник. Должен иметь конструктор, принимающий x1, y1, x2, y2, x3, y3 – шесть координат.
    В качестве ширины возвращать max(x1, x2, x3) – min(x1, x2, x3)
    В качестве высоты возвращать max(y1, y2, y3) – min(y1, y2, y3)

4.	Rectangle – прямоугольник. Должен иметь конструктор, принимающий длины двух сторон.

5.	Circle – окружность. Должна иметь конструктор, принимающий радиус. В качестве ширины и высоты должен выдаваться диаметр.

**Часть 2.** Написать функцию, которая находит фигуру с максимальной площадью. 
В main объявить массив фигур, чтобы в нём было около 5-10 разных фигур. 
Вызвать функцию для этого массива и распечатать информацию о фигуре в консоль. 
Аналогично найдите фигуру со вторым по величине периметром.
Поиск фигур реализовать через стандартный метод с компаратором.

**Часть 3.** Переопределите в фигурах методы toString, hashCode, equals.


### <span id="vector">Задача [Vector](Vector):</span>

Реализовать класс Vector для векторов вещественных чисел размерности n. 
Компоненты вектора хранить массивом. 
Номера компонент отсчитываются от нуля.

Конструктор вектора должен принимать число n – размерность вектора. 
Если n <= 0, то нужно бросать исключение.

Для этого класса нужно реализовать:

1.	Конструкторы
    - Vector(n) – размерность n, все компоненты равны 0
    - Vector(Vector) – конструктор копирования
    - Vector(double[]) – заполнение вектора значениями из массива
    - Vector(n, double[]) – заполнение вектора значениями из массива. Если длина массива меньше n, то считать что в остальных компонентах 0
      
2.	Метод getSize() для получения размерности вектора

3.	Реализовать метод toString(), чтобы выдавал информацию о векторе в  формате { значения компонент через запятую }

4.	Реализовать  нестатические методы:
    - Прибавление к вектору другого вектора
    - Вычитание из вектора другого вектора
    - Умножение вектора на скаляр
    -	Разворот вектора
    -	Получение длины вектора
    -	Получение и установка компоненты вектора по индексу
    -	Переопределить метод equals. Соответственно, переопределить hashCode

5.	Реализовать статические методы:
    -	Сложение двух векторов – должен создаваться новый вектор
    - Вычитание векторов – должен создаваться новый вектор
    - Скалярное произведение векторов
      
Если операции выполняются над векторами разной размерности, то считать что у меньшего вектора в недостающих компонентах нули
В main написать небольшую тестовую программу


### <span id="matrix">Задача [Matrix](Matrix):</span>

Реализовать класс матрицы Matrix с использованием класса Vector.

Во всех методах, кроме конструкторов, если размеры входных данных неверные, то кидать исключение. 
В конструкторах нужно добить данные нулями до нужной длины.

Реализовать:

1.	Конструкторы:
    - Matrix(n, m) – матрица нулей размера nxm
    - Matrix(Matrix) – конструктор копирования
    - Matrix(double[][]) – из двумерного массива
    - Matrix(Vector[]) – из массива векторов-строк
      
2.	Методы:
    - Получение размеров матрицы
    - Получение и задание вектора-строки по индексу	
    - Получение вектора-столбца по индексу
    - Транспонирование матрицы
    - Умножение на скаляр
    - Вычисление определителя матрицы
    - toString определить так, чтобы результат получался в таком виде: {{1, 2}, {2, 3}}
    - Умножение матрицы на вектор
    - Сложение матриц
    - Вычитание матриц
      
3.	Статические методы:
    - Сложение матриц 
    - Вычитание матриц
    - Умножение матриц


### <span id="list">Задача [List](List):</span>

Создать классы для односвязного списка и узла списка.

- Для эффективности сделайте поле для хранения длины списка.
  
Реализовать методы:

  - Получение размера списка
  - Получение значения первого элемента
  - Получение/изменение значения по указанному индексу
    (изменение значения по индексу пусть выдает старое значение)
  - Удаление элемента по индексу (пусть выдает значение элемента)
  - Вставка элемента в начало
  - Вставка элемента по индексу
  - Удаление узла по значению (пусть выдает true, если элемент был удален)
  - Удаление первого элемента (пусть выдает значение элемента)
  - Разворот списка за линейное время
  - Копирование списка


### <span id="array-list">Задача [ArrayList](ArrayList):</span>

- Сделать свою реализацию списка ArrayList<T>, сделать его generic’ом
- Реализовать итератор
- Реализовать специфичный конструктор, принимающий вместимость
- Реализовать методы ensureCapacity и trimToSize


### <span id="array-list-home">Задача [ArrayListHome](ArrayListHome):</span>

1. Прочитать в список все строки из файла.

2. Есть список из целых чисел. Удалить из него все четные числа. В этой задаче новый список создавать нельзя.

3. Есть список из целых чисел, в нём некоторые числа могут повторяться.
   Надо создать новый список, в котором будут элементы первого списка в таком же порядке, но без повторений.


### <span id="hash-table">Задача [HashTable](HashTable):</span>

Сделать свою реализацию хэш-таблицы, сделать ее generic’ом. Класс должен реализовать интерфейс Collection<T>.
В одном из конструкторов сделать параметр, который задает размер массива хэш-таблицы.


### <span id="binary-search-tree">Задача [BinarySearchTree](BinarySearchTree):</span>

Реализовать бинарное дерево поиска

Нужные операции:
1.	Вставка
2.	Поиск узла
3.	Удаление первого вхождения узла по значению
4.	Получение числа элементов
5.	Обходы в ширину
6.	Обход в глубину двумя вариантами – с рекурсией и без


### <span id="graph">Задача [Graph](Graph):</span>

Реализовать обход несвязного графа в ширину и глубину.
Граф задается двумерным массивом.

### <span id="lambda">Задача [Лямбда-функции](Lambda):</span>

Создать класс Person с полями имя и возраст. 
Сделать конструктор, который принимает эти параметры. Сделать геттеры для полей.
В main создать список из нескольких людей.

При помощи лямбда-функций:

 - Получить список уникальных имен
 - Вывести список уникальных имен в формате: "Имена: Иван, Сергей, Петр."
 - Получить список людей младше 18, посчитать для них средний возраст
 - При помощи группировки получить Map, в котором ключи – имена, а значения – средний возраст
 - Получить людей, возраст которых от 20 до 45, вывести в консоль их имена в порядке убывания возраста


### <span id="temperature">Задача [Temperature](Temperature):</span>

Сделать программу на Swing по шаблону MVC для перевода температуры из одной шкалы в другую в соответствии с принципами SOLID.

Необходимая функциональность:
1.	Ввод температуры в поле ввода
2.	Должна быть кнопка, которая переводит температуру из одной шкалы в другую
3.	Результат перевода должен выводиться на форму, при этом быть не редактируемым
4.	Можно задать из какой шкалы и в какую переводить
5.	Доступные шкалы: цельсия, фаренгейта, кельвина
6.	Если ввели не число, то нужно вывести ошибку
7.	Обязательно использовать layout manager’ы


### <span id="thread-pool">Задача [Пул потоков](ThreadPool):<span>

Реализовать пул потоков

### <span id="producer-consumer">Задача [Производитель - Потребитель](ProducerConsumerThreads):</span>

Есть несколько потоков-производителей. Они выполняют некоторую работу, и кладут результат в список определенной вместимости.
Есть несколько потоков-потребителей. Они ждут когда в этом списке что-то появится, и забирают результат оттуда по одному элементу.
Необходимо реализовать это взаимодействие потоков, и чтобы потоки были правильно синхронизованы.
